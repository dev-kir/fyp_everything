{
  "metadata": {
    "generated": "2025-12-27",
    "purpose": "Structured table data for Chapter 4 thesis writing",
    "source": "SwarmGuard experimental test results",
    "note": "All values are actual measurements from test runs"
  },

  "table_4_1_baseline_mttr": {
    "title": "Table 4.1: Baseline MTTR Measurements (Reactive Docker Swarm Recovery)",
    "description": "Mean Time To Recovery for 10 baseline tests using reactive Docker Swarm health checks without SwarmGuard",
    "columns": ["Test Number", "MTTR (seconds)", "Downtime Duration", "Recovery Method"],
    "data": [
      {"test": 1, "mttr": 24.0, "downtime": "24 seconds", "method": "Reactive restart"},
      {"test": 2, "mttr": 25.0, "downtime": "25 seconds", "method": "Reactive restart"},
      {"test": 3, "mttr": 24.0, "downtime": "24 seconds", "method": "Reactive restart"},
      {"test": 4, "mttr": 21.0, "downtime": "21 seconds", "method": "Reactive restart"},
      {"test": 5, "mttr": 25.0, "downtime": "25 seconds", "method": "Reactive restart"},
      {"test": 6, "mttr": 21.0, "downtime": "21 seconds", "method": "Reactive restart"},
      {"test": 7, "mttr": 22.0, "downtime": "22 seconds", "method": "Reactive restart"},
      {"test": 8, "mttr": 21.0, "downtime": "21 seconds", "method": "Reactive restart"},
      {"test": 9, "mttr": 24.0, "downtime": "24 seconds", "method": "Reactive restart"},
      {"test": 10, "mttr": 24.0, "downtime": "24 seconds", "method": "Reactive restart"}
    ],
    "statistics": {
      "mean": 23.1,
      "median": 24.0,
      "min": 21.0,
      "max": 25.0,
      "std_dev": 1.49,
      "sample_size": 10
    }
  },

  "table_4_2_scenario1_mttr": {
    "title": "Table 4.2: Scenario 1 MTTR Measurements (Proactive Migration with SwarmGuard)",
    "description": "Mean Time To Recovery for 10 Scenario 1 tests using proactive container migration",
    "columns": ["Test Number", "MTTR (seconds)", "Zero-Downtime?", "Recovery Method"],
    "data": [
      {"test": 1, "mttr": 0.0, "zero_downtime": true, "method": "Proactive migration"},
      {"test": 2, "mttr": 0.0, "zero_downtime": true, "method": "Proactive migration"},
      {"test": 3, "mttr": 0.0, "zero_downtime": true, "method": "Proactive migration"},
      {"test": 4, "mttr": 0.0, "zero_downtime": true, "method": "Proactive migration"},
      {"test": 5, "mttr": 0.0, "zero_downtime": true, "method": "Proactive migration"},
      {"test": 6, "mttr": 0.0, "zero_downtime": true, "method": "Proactive migration"},
      {"test": 7, "mttr": 1.0, "zero_downtime": false, "method": "Proactive migration (brief delay)"},
      {"test": 8, "mttr": 0.0, "zero_downtime": true, "method": "Proactive migration"},
      {"test": 9, "mttr": 5.0, "zero_downtime": false, "method": "Proactive migration (delayed)"},
      {"test": 10, "mttr": 0.0, "zero_downtime": true, "method": "Proactive migration"}
    ],
    "statistics": {
      "mean": 0.6,
      "median": 0.0,
      "min": 0.0,
      "max": 5.0,
      "std_dev": 1.55,
      "sample_size": 10,
      "zero_downtime_count": 8,
      "zero_downtime_rate_percent": 80.0
    }
  },

  "table_4_3_mttr_comparison": {
    "title": "Table 4.3: MTTR Comparison - Baseline vs SwarmGuard",
    "description": "Statistical comparison of reactive (baseline) vs proactive (SwarmGuard) recovery",
    "columns": ["Metric", "Baseline (Reactive)", "SwarmGuard (Proactive)", "Improvement"],
    "data": [
      {
        "metric": "Mean MTTR",
        "baseline": "23.1 seconds",
        "swarmguard": "0.6 seconds",
        "improvement": "22.5s reduction (97.4%)"
      },
      {
        "metric": "Median MTTR",
        "baseline": "24.0 seconds",
        "swarmguard": "0.0 seconds",
        "improvement": "24.0s reduction (100%)"
      },
      {
        "metric": "Best Case (Min)",
        "baseline": "21.0 seconds",
        "swarmguard": "0.0 seconds",
        "improvement": "21.0s reduction (100%)"
      },
      {
        "metric": "Worst Case (Max)",
        "baseline": "25.0 seconds",
        "swarmguard": "5.0 seconds",
        "improvement": "20.0s reduction (80%)"
      },
      {
        "metric": "Zero-Downtime Rate",
        "baseline": "0% (0/10 tests)",
        "swarmguard": "80% (8/10 tests)",
        "improvement": "+80 percentage points"
      },
      {
        "metric": "Service Availability",
        "baseline": "99.36% (during failure)",
        "swarmguard": "99.98% (during failure)",
        "improvement": "+0.62% availability"
      }
    ]
  },

  "table_4_4_scenario2_scaling": {
    "title": "Table 4.4: Scenario 2 Horizontal Scaling Performance",
    "description": "Replica scaling behavior for 10 Scenario 2 tests",
    "columns": ["Test Number", "Initial Replicas", "Max Replicas", "Scaling Events", "Result"],
    "data": [
      {"test": 1, "initial": 1, "max": 2, "events": 2, "result": "Success"},
      {"test": 2, "initial": 1, "max": 3, "events": 3, "result": "Success (aggressive)"},
      {"test": 3, "initial": 1, "max": 2, "events": 2, "result": "Success"},
      {"test": 4, "initial": 1, "max": 2, "events": 2, "result": "Success"},
      {"test": 5, "initial": 1, "max": 2, "events": 2, "result": "Success"},
      {"test": 6, "initial": 1, "max": 2, "events": 1, "result": "Success (conservative)"},
      {"test": 7, "initial": 1, "max": 2, "events": 2, "result": "Success"},
      {"test": 8, "initial": 1, "max": 2, "events": 2, "result": "Success"},
      {"test": 9, "initial": 1, "max": 3, "events": 4, "result": "Success (oscillation)"},
      {"test": 10, "initial": 1, "max": 2, "events": 2, "result": "Success"}
    ],
    "statistics": {
      "avg_max_replicas": 2.2,
      "min_replicas": 2,
      "max_replicas": 3,
      "avg_scaling_events": 2.2,
      "success_rate_percent": 100.0
    }
  },

  "table_4_5_cpu_overhead": {
    "title": "Table 4.5: CPU Overhead by Node",
    "description": "CPU overhead comparison across three scenarios: Baseline, Monitoring Only, Full SwarmGuard",
    "columns": ["Node", "Baseline (%)", "Monitoring Only (%)", "Full SwarmGuard (%)", "Overhead (%)"],
    "data": [
      {
        "node": "master (odin)",
        "baseline": 2.24,
        "monitoring_only": 3.08,
        "full_swarmguard": 2.37,
        "overhead": 0.13,
        "note": "Recovery manager overhead"
      },
      {
        "node": "worker-1 (thor)",
        "baseline": 1.30,
        "monitoring_only": 1.32,
        "full_swarmguard": 0.97,
        "overhead": -0.33,
        "note": "Lower CPU usage with SwarmGuard"
      },
      {
        "node": "worker-2 (loki)",
        "baseline": 0.67,
        "monitoring_only": 0.68,
        "full_swarmguard": 0.71,
        "overhead": 0.04,
        "note": "Negligible overhead"
      },
      {
        "node": "worker-3 (heimdall)",
        "baseline": 1.22,
        "monitoring_only": 1.15,
        "full_swarmguard": 1.21,
        "overhead": -0.01,
        "note": "Negligible overhead"
      },
      {
        "node": "worker-4 (freya)",
        "baseline": 1.27,
        "monitoring_only": 1.06,
        "full_swarmguard": 0.97,
        "overhead": -0.30,
        "note": "Lower CPU usage with SwarmGuard"
      }
    ],
    "statistics": {
      "cluster_avg_baseline": 1.34,
      "cluster_avg_full_swarmguard": 1.25,
      "cluster_avg_overhead": -0.09,
      "cluster_avg_overhead_percent": -6.7,
      "note": "Negative overhead indicates SwarmGuard actually reduced CPU usage"
    }
  },

  "table_4_6_memory_overhead": {
    "title": "Table 4.6: Memory Overhead by Node",
    "description": "Memory overhead comparison across three scenarios",
    "columns": ["Node", "Baseline (MB)", "Full SwarmGuard (MB)", "Overhead (MB)", "Overhead (%)"],
    "data": [
      {
        "node": "master (odin)",
        "baseline_mb": 2109.6,
        "full_swarmguard_mb": 2180.98,
        "overhead_mb": 71.38,
        "overhead_percent": 3.38,
        "note": "Includes recovery manager"
      },
      {
        "node": "worker-1 (thor)",
        "baseline_mb": 567.98,
        "full_swarmguard_mb": 603.67,
        "overhead_mb": 35.69,
        "overhead_percent": 6.28,
        "note": "Monitoring agent overhead"
      },
      {
        "node": "worker-2 (loki)",
        "baseline_mb": 840.88,
        "full_swarmguard_mb": 875.23,
        "overhead_mb": 34.35,
        "overhead_percent": 4.08,
        "note": "Monitoring agent overhead"
      },
      {
        "node": "worker-3 (heimdall)",
        "baseline_mb": 607.33,
        "full_swarmguard_mb": 646.25,
        "overhead_mb": 38.92,
        "overhead_percent": 6.41,
        "note": "Monitoring agent overhead"
      },
      {
        "node": "worker-4 (freya)",
        "baseline_mb": 671.95,
        "full_swarmguard_mb": 712.97,
        "overhead_mb": 41.02,
        "overhead_percent": 6.11,
        "note": "Monitoring agent overhead"
      }
    ],
    "statistics": {
      "cluster_total_baseline_mb": 4797.74,
      "cluster_total_full_swarmguard_mb": 5019.10,
      "cluster_total_overhead_mb": 221.36,
      "cluster_total_overhead_percent": 4.61,
      "avg_per_node_overhead_mb": 44.27,
      "avg_per_node_overhead_percent": 5.25
    }
  },

  "table_4_7_threshold_configuration": {
    "title": "Table 4.7: SwarmGuard Threshold Configuration",
    "description": "Threshold values used for scenario classification",
    "columns": ["Threshold", "Value", "Unit", "Purpose"],
    "data": [
      {
        "threshold": "CPU Threshold",
        "value": 75,
        "unit": "%",
        "purpose": "Trigger for both scenarios when exceeded"
      },
      {
        "threshold": "Memory Threshold",
        "value": 80,
        "unit": "%",
        "purpose": "Trigger for both scenarios when exceeded"
      },
      {
        "threshold": "Network Low Threshold",
        "value": 35,
        "unit": "%",
        "purpose": "Scenario 1 (Migration): Network below this value"
      },
      {
        "threshold": "Network High Threshold",
        "value": 65,
        "unit": "%",
        "purpose": "Scenario 2 (Scaling): Network above this value"
      },
      {
        "threshold": "Consecutive Breaches",
        "value": 2,
        "unit": "count",
        "purpose": "Number of consecutive threshold breaches required"
      },
      {
        "threshold": "Migration Cooldown",
        "value": 60,
        "unit": "seconds",
        "purpose": "Minimum time between migrations"
      },
      {
        "threshold": "Scale-Up Cooldown",
        "value": 60,
        "unit": "seconds",
        "purpose": "Minimum time between scale-up operations"
      },
      {
        "threshold": "Scale-Down Cooldown",
        "value": 180,
        "unit": "seconds",
        "purpose": "Minimum time between scale-down operations"
      }
    ]
  },

  "table_4_8_scenario_classification": {
    "title": "Table 4.8: Scenario Classification Rules",
    "description": "Decision rules for classifying workload scenarios",
    "columns": ["Scenario", "CPU/Memory Condition", "Network Condition", "Recovery Action"],
    "data": [
      {
        "scenario": "Scenario 1 (Migration)",
        "cpu_memory": "CPU > 75% OR Memory > 80%",
        "network": "Network < 35%",
        "action": "Migrate container to healthy node using start-first update"
      },
      {
        "scenario": "Scenario 2 (Scaling)",
        "cpu_memory": "CPU > 75% OR Memory > 80%",
        "network": "Network > 65%",
        "action": "Horizontally scale replicas (increase by 1)"
      },
      {
        "scenario": "No Action Zone",
        "cpu_memory": "CPU > 75% OR Memory > 80%",
        "network": "35% ≤ Network ≤ 65%",
        "action": "No action (ambiguous workload pattern)"
      },
      {
        "scenario": "Healthy State",
        "cpu_memory": "CPU ≤ 75% AND Memory ≤ 80%",
        "network": "Any",
        "action": "No action (normal operation)"
      }
    ]
  },

  "table_4_9_test_environment": {
    "title": "Table 4.9: Experimental Test Environment Specifications",
    "description": "Hardware and software configuration for experimental testbed",
    "columns": ["Component", "Specification", "Notes"],
    "data": [
      {
        "component": "Cluster Size",
        "specification": "5 nodes (1 master + 4 workers)",
        "notes": "Physical Dell OptiPlex machines"
      },
      {
        "component": "Node Names",
        "specification": "odin (master), thor, loki, heimdall, freya (workers)",
        "notes": "Norse mythology naming convention"
      },
      {
        "component": "Network",
        "specification": "100 Mbps Ethernet",
        "notes": "Dell PowerConnect switch"
      },
      {
        "component": "Docker Version",
        "specification": "24.0.x",
        "notes": "Docker Swarm mode enabled"
      },
      {
        "component": "Monitoring Agents",
        "specification": "Python 3.8+ (asyncio)",
        "notes": "1 per worker node (4 total)"
      },
      {
        "component": "Recovery Manager",
        "specification": "Python 3.8+ (Flask)",
        "notes": "1 instance on master node"
      },
      {
        "component": "Time-Series DB",
        "specification": "InfluxDB 2.x",
        "notes": "Metrics storage and querying"
      },
      {
        "component": "Visualization",
        "specification": "Grafana",
        "notes": "Real-time dashboards"
      },
      {
        "component": "Test Application",
        "specification": "Node.js Express (web-stress)",
        "notes": "Load testing target"
      },
      {
        "component": "Stress Testing",
        "specification": "stress-ng, iperf3",
        "notes": "CPU and network load injection"
      }
    ]
  },

  "table_4_10_research_questions_summary": {
    "title": "Table 4.10: Research Questions and Experimental Results Summary",
    "description": "Summary of research questions and findings",
    "columns": ["Research Question", "Hypothesis", "Result", "Evidence"],
    "data": [
      {
        "rq": "RQ1: MTTR Reduction",
        "question": "Can proactive recovery reduce Mean Time To Recovery?",
        "hypothesis": "Proactive recovery will reduce MTTR by >50%",
        "result": "YES - 97.4% reduction",
        "evidence": "23.1s (baseline) → 0.6s (SwarmGuard)"
      },
      {
        "rq": "RQ2: Zero-Downtime Migration",
        "question": "Can zero-downtime migration be achieved?",
        "hypothesis": "Zero-downtime achievable in majority of cases",
        "result": "YES - 80% success rate",
        "evidence": "8 out of 10 tests achieved 0s downtime"
      },
      {
        "rq": "RQ3: System Overhead",
        "question": "What is the performance overhead of SwarmGuard?",
        "hypothesis": "Overhead will be <10%",
        "result": "YES - Minimal overhead",
        "evidence": "CPU: -0.09%, Memory: +4.6% (~44 MB/node)"
      },
      {
        "rq": "RQ4: Horizontal Scaling",
        "question": "Can SwarmGuard effectively autoscale based on load?",
        "hypothesis": "Autoscaling will handle high-load scenarios",
        "result": "YES - 100% success rate",
        "evidence": "All 10 tests successfully scaled to 2-3 replicas"
      }
    ]
  }
}
