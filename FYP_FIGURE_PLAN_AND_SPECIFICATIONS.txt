================================================================================
SWARMGUARD FYP: COMPREHENSIVE FIGURE PLAN AND SPECIFICATIONS
================================================================================

COMPREHENSIVE VISUAL PRESENTATION GUIDE FOR ACADEMIC FYP REPORT
(LaTeX-Ready Figure Specifications with TikZ Structure)

This document provides precise specifications for all figures, diagrams, tables,
and visual elements required across Chapters 1-5 of your FYP report.

================================================================================
TABLE OF CONTENTS
================================================================================

PART 1: CHAPTER 1 FIGURES (Introduction)
PART 2: CHAPTER 2 FIGURES (Literature Review)
PART 3: CHAPTER 3 FIGURES - ARCHITECTURE (Methodology - Design)
PART 4: CHAPTER 3 FIGURES - ALGORITHMS (Methodology - Implementation)
PART 5: CHAPTER 4 FIGURES (Results and Discussion)
PART 6: LATEX TIKZ TEMPLATES AND BEST PRACTICES

================================================================================
PART 1: CHAPTER 1 FIGURES (Introduction)
================================================================================

Chapter 1 requires minimal figures focused on problem visualization and
project context.

--------------------------------------------------------------------------------
FIGURE 1.1: Reactive vs Proactive Recovery Comparison
--------------------------------------------------------------------------------

CHAPTER SECTION: 1.1 Problem Statement
PLACEMENT: After introducing the problem of container failures

FIGURE TITLE:
"Comparison of Reactive and Proactive Recovery Approaches in Container
Orchestration"

FIGURE CAPTION:
"Timeline comparison showing reactive recovery (Docker Swarm default) versus
proactive recovery (SwarmGuard). Reactive approach waits for container failure
before initiating recovery, resulting in downtime. Proactive approach detects
early warning signs (resource threshold violations) and initiates recovery
before failure occurs, achieving zero downtime."

DESCRIPTION FOR LATEX (TikZ Timeline):

Two horizontal timelines stacked vertically:

TIMELINE 1 (Reactive Recovery - Docker Swarm):
├─────────────┼──────────┼─────────────┼───────────────┤
0s            15s        25s           40s
│             │          │             │
│             │          │             └─ New container healthy
│             │          └─ Recovery initiated
│             └─ Container fails (health check)
└─ Normal operation

Downtime: 15s to 40s (marked with RED shading)
MTTR: 25 seconds (15s detection + 10s recovery)

TIMELINE 2 (Proactive Recovery - SwarmGuard):
├─────┼─────────────────────────────────┼──────────────┤
0s    10s                               16s
│     │                                 │
│     │                                 └─ Migration complete
│     └─ Threshold detected, migration starts
└─ Normal operation

Zero-Downtime Window: 10s to 16s (GREEN shading, both containers running)
MTTR: 6 seconds

TIKZ STRUCTURE:
```latex
\begin{tikzpicture}
  % Reactive timeline
  \draw[very thick] (0,2) -- (10,2);
  \fill[red!30] (3,1.8) rectangle (8,2.2); % Downtime
  \node at (0,2) [below] {0s};
  \node at (3,2) [below] {15s};
  \node at (5,2) [below] {25s};
  \node at (8,2) [below] {40s};

  % Proactive timeline
  \draw[very thick] (0,0) -- (10,0);
  \fill[green!30] (2,-0.2) rectangle (4,0.2); % Zero downtime
  \node at (0,0) [below] {0s};
  \node at (2,0) [below] {10s};
  \node at (4,0) [below] {16s};

  % Labels and annotations
  \node at (5.5,2.5) {Reactive (Docker Swarm)};
  \node at (3,0.5) {Proactive (SwarmGuard)};
\end{tikzpicture}
```

--------------------------------------------------------------------------------
FIGURE 1.2: SwarmGuard Deployment Environment
--------------------------------------------------------------------------------

CHAPTER SECTION: 1.4 Project Scope and Limitations
PLACEMENT: When describing the target environment

FIGURE TITLE:
"SwarmGuard Deployment Environment and Infrastructure"

FIGURE CAPTION:
"Physical infrastructure showing Docker Swarm cluster (5 nodes: 1 master + 4
workers), external monitoring infrastructure (InfluxDB and Grafana on Raspberry
Pi), and distributed load testing cluster (4 Alpine Linux Raspberry Pi nodes).
All connected via 100Mbps Ethernet network."

DESCRIPTION FOR LATEX (TikZ Network Diagram):

Layer 1 (Docker Swarm Cluster):
┌──────────┐
│  Master  │ (manager node, runs recovery-manager)
└────┬─────┘
     │
     ├─── Worker-1 (monitoring-agent-1)
     ├─── Worker-2 (monitoring-agent-2)
     ├─── Worker-3 (monitoring-agent-3)
     └─── Worker-4 (monitoring-agent-4)

Layer 2 (Monitoring Infrastructure):
┌─────────────┐    ┌──────────┐
│  InfluxDB   │────│ Grafana  │
│ (Raspberry  │    │(Rasp Pi) │
│     Pi)     │    │          │
└─────────────┘    └──────────┘

Layer 3 (Load Testing):
Alpine-1, Alpine-2, Alpine-3, Alpine-4 (4 Raspberry Pi 1.2B+ nodes)

Network: 100Mbps Ethernet Switch (constraint labeled)

TIKZ STRUCTURE:
```latex
\begin{tikzpicture}[
  node/.style={rectangle,draw,minimum width=2cm,minimum height=1cm},
  switch/.style={diamond,draw,minimum size=1.5cm}
]
  % Swarm cluster
  \node[node] (master) at (0,4) {Master};
  \node[node] (w1) at (-3,2) {Worker-1};
  \node[node] (w2) at (-1,2) {Worker-2};
  \node[node] (w3) at (1,2) {Worker-3};
  \node[node] (w4) at (3,2) {Worker-4};

  % Network switch
  \node[switch] (switch) at (0,0) {100Mbps};

  % Monitoring infrastructure
  \node[node] (influx) at (-4,-2) {InfluxDB};
  \node[node] (grafana) at (-2,-2) {Grafana};

  % Load testing
  \node[node] (alpine) at (2,-2) {Alpine×4};

  % Connections
  \draw[thick] (master) -- (switch);
  \draw[thick] (w1) -- (switch);
  \draw[thick] (w2) -- (switch);
  \draw[thick] (w3) -- (switch);
  \draw[thick] (w4) -- (switch);
  \draw[thick] (influx) -- (switch);
  \draw[thick] (grafana) -- (switch);
  \draw[thick] (alpine) -- (switch);
\end{tikzpicture}
```

--------------------------------------------------------------------------------
FIGURE 1.3: Research Objectives Mapping
--------------------------------------------------------------------------------

CHAPTER SECTION: 1.3 Research Objectives
PLACEMENT: After listing objectives

FIGURE TITLE:
"Research Objectives and Their Validation Metrics"

FIGURE CAPTION:
"Mapping of five research objectives to their corresponding validation metrics
and achieved results, demonstrating alignment between goals and outcomes."

DESCRIPTION FOR LATEX (Table):

TABLE STRUCTURE:
| Objective | Target Metric | Achieved | Validation Method |
|-----------|---------------|----------|-------------------|
| RO1: Reduce MTTR | < 10 seconds | 6.08 seconds | Scenario 1 testing |
| RO2: Zero downtime | 0 seconds | 0 seconds | Alpine Pi health checks |
| RO3: Scenario detection | 2 scenarios | 2 scenarios | Rule engine validation |
| RO4: Minimal overhead | < 5% CPU | < 2% CPU | System monitoring |
| RO5: Practical feasibility | Working system | Deployed | End-to-end testing |

LATEX TABLE STRUCTURE:
```latex
\begin{table}[h]
\centering
\caption{Research Objectives and Validation Metrics}
\begin{tabular}{|p{4cm}|p{2.5cm}|p{2cm}|p{3.5cm}|}
\hline
\textbf{Objective} & \textbf{Target} & \textbf{Achieved} & \textbf{Validation} \\
\hline
RO1: Reduce MTTR & < 10 sec & 6.08 sec & Scenario 1 testing \\
\hline
RO2: Zero downtime & 0 sec & 0 sec & Alpine Pi checks \\
\hline
% ... continue for all objectives
\hline
\end{tabular}
\label{tab:objectives}
\end{table}
```

================================================================================
PART 2: CHAPTER 2 FIGURES (Literature Review)
================================================================================

Chapter 2 requires conceptual diagrams for positioning your work in the
academic landscape.

--------------------------------------------------------------------------------
FIGURE 2.1: MAPE-K Loop Framework
--------------------------------------------------------------------------------

CHAPTER SECTION: 2.3 Self-Adaptive Systems and Autonomic Computing
PLACEMENT: When introducing MAPE-K control loop

FIGURE TITLE:
"MAPE-K Control Loop Applied to SwarmGuard Architecture"

FIGURE CAPTION:
"The Monitor-Analyze-Plan-Execute-Knowledge (MAPE-K) framework adapted for
container orchestration. SwarmGuard implements this autonomic computing pattern
with monitoring agents (Monitor), rule engine (Analyze), recovery strategies
(Plan), Docker API calls (Execute), and configuration repository (Knowledge)."

DESCRIPTION FOR LATEX (TikZ Cycle Diagram):

Circular flow with 5 components:

1. MONITOR (Top)
   - Monitoring agents
   - Docker stats API
   - Threshold detection

2. ANALYZE (Right)
   - Rule engine
   - Scenario detection
   - Consecutive breach check

3. PLAN (Bottom-Right)
   - Scenario 1 → Migration
   - Scenario 2 → Scaling
   - Cooldown management

4. EXECUTE (Bottom-Left)
   - Docker Swarm API
   - service.update() or service.scale()
   - Placement constraints

5. KNOWLEDGE (Left)
   - Configuration (YAML)
   - Thresholds
   - Cooldown periods
   - Min/max replicas

Center: "Managed Element" (Docker Swarm Cluster)

TIKZ STRUCTURE:
```latex
\begin{tikzpicture}[
  component/.style={rectangle,draw,thick,minimum width=2.5cm,minimum height=1.5cm,align=center},
  arrow/.style={->,>=stealth,thick}
]
  % Central managed element
  \node[draw,circle,minimum size=3cm] (center) at (0,0) {Docker\\Swarm\\Cluster};

  % MAPE-K components in circle
  \node[component,fill=blue!20] (monitor) at (0,4) {Monitor\\(Agents)};
  \node[component,fill=green!20] (analyze) at (3.5,2) {Analyze\\(Rules)};
  \node[component,fill=yellow!20] (plan) at (3.5,-2) {Plan\\(Strategy)};
  \node[component,fill=red!20] (execute) at (-3.5,-2) {Execute\\(Docker API)};
  \node[component,fill=purple!20] (knowledge) at (-3.5,2) {Knowledge\\(Config)};

  % Arrows forming cycle
  \draw[arrow] (monitor) -- (analyze);
  \draw[arrow] (analyze) -- (plan);
  \draw[arrow] (plan) -- (execute);
  \draw[arrow] (execute) -- (knowledge);
  \draw[arrow] (knowledge) -- (monitor);

  % Connections to managed element
  \draw[arrow,dashed] (monitor) -- (center);
  \draw[arrow,dashed] (execute) -- (center);
\end{tikzpicture}
```

--------------------------------------------------------------------------------
FIGURE 2.2: Container Orchestration Landscape
--------------------------------------------------------------------------------

CHAPTER SECTION: 2.2 Container Orchestration Technologies
PLACEMENT: When comparing orchestration platforms

FIGURE TITLE:
"Container Orchestration Platform Comparison Matrix"

FIGURE CAPTION:
"Comparison of major container orchestration platforms across key dimensions:
complexity, scalability, feature richness, and learning curve. SwarmGuard
targets the Docker Swarm ecosystem, balancing simplicity with proactive
recovery capabilities."

DESCRIPTION FOR LATEX (Comparison Table):

TABLE STRUCTURE:
| Platform | Complexity | Max Scale | Proactive Features | Learning Curve | Use Case |
|----------|-----------|-----------|-------------------|----------------|----------|
| Docker Swarm | Low | < 50 nodes | Health checks only | Gentle | SME, simple deployments |
| Kubernetes | High | 1000s nodes | HPA, VPA, custom operators | Steep | Enterprise, cloud-native |
| Nomad | Medium | 100s nodes | Scaling policies | Moderate | Multi-workload |
| Mesos | High | 1000s nodes | Marathon framework | Steep | Legacy large-scale |
| SwarmGuard | Low+ | < 20 nodes | Proactive migration + scaling | Gentle | Docker Swarm + proactive |

LATEX TABLE:
```latex
\begin{table}[h]
\centering
\caption{Container Orchestration Platform Comparison}
\begin{tabular}{|l|c|c|p{3cm}|c|p{3cm}|}
\hline
\textbf{Platform} & \textbf{Complexity} & \textbf{Scale} & \textbf{Proactive} & \textbf{Learning} & \textbf{Use Case} \\
\hline
Docker Swarm & Low & <50 & Health checks & Gentle & SME \\
\hline
Kubernetes & High & 1000s & HPA, VPA & Steep & Enterprise \\
\hline
SwarmGuard & Low+ & <20 & Migration+Scale & Gentle & Swarm+Proactive \\
\hline
\end{tabular}
\label{tab:orchestration-comparison}
\end{table}
```

--------------------------------------------------------------------------------
FIGURE 2.3: Research Gap Positioning
--------------------------------------------------------------------------------

CHAPTER SECTION: 2.6 Research Gap and Contribution
PLACEMENT: At end of literature review

FIGURE TITLE:
"Positioning of SwarmGuard in the Research Landscape"

FIGURE CAPTION:
"Venn diagram showing the intersection of three research domains: autonomic
computing (self-healing systems), container orchestration (Docker Swarm), and
proactive failure prediction. SwarmGuard occupies the intersection, addressing
the gap of proactive recovery mechanisms for Docker Swarm environments."

DESCRIPTION FOR LATEX (TikZ Venn Diagram):

Three overlapping circles:

CIRCLE 1 (Blue): "Autonomic Computing"
- MAPE-K frameworks
- Self-healing systems
- Adaptive architectures

CIRCLE 2 (Green): "Container Orchestration"
- Docker Swarm
- Kubernetes
- Service mesh

CIRCLE 3 (Red): "Proactive Failure Prediction"
- Threshold-based detection
- Predictive analytics
- Early warning systems

INTERSECTION (All Three): "SwarmGuard" (highlighted)

TIKZ STRUCTURE:
```latex
\begin{tikzpicture}
  % Draw three circles
  \draw[thick,fill=blue!20,opacity=0.5] (0,0) circle (2.5cm);
  \draw[thick,fill=green!20,opacity=0.5] (3,0) circle (2.5cm);
  \draw[thick,fill=red!20,opacity=0.5] (1.5,2.5) circle (2.5cm);

  % Labels for each circle
  \node at (-1.5,-1.5) {Autonomic\\Computing};
  \node at (4.5,-1.5) {Container\\Orchestration};
  \node at (1.5,4) {Proactive\\Failure\\Prediction};

  % Central intersection (SwarmGuard)
  \node[draw,fill=yellow!50,circle,minimum size=1.5cm] at (1.5,0.8) {\textbf{SwarmGuard}};
\end{tikzpicture}
```

--------------------------------------------------------------------------------
FIGURE 2.4: Related Work Timeline
--------------------------------------------------------------------------------

CHAPTER SECTION: 2.5 Related Work Summary
PLACEMENT: After discussing related research

FIGURE TITLE:
"Evolution of Proactive Recovery Approaches in Distributed Systems"

FIGURE CAPTION:
"Timeline of key developments in proactive recovery and self-healing systems
from autonomic computing (2003) to modern container orchestration, positioning
SwarmGuard within this progression."

DESCRIPTION FOR LATEX (Timeline):

Horizontal timeline from 2003 to 2025:

2003: Autonomic Computing (Kephart & Chess)
2006: Virtual Machine Live Migration (VMware vMotion)
2010: Proactive Failure Prediction (Salfner et al.)
2014: Docker containerization emerges
2015: Kubernetes v1.0 released
2016: Docker Swarm mode introduced
2018: Kubernetes HPA widespread adoption
2020-2023: ML-based predictive models
2025: SwarmGuard (rule-based proactive recovery for Swarm)

TIKZ STRUCTURE:
```latex
\begin{tikzpicture}
  % Timeline axis
  \draw[thick,->] (0,0) -- (14,0);

  % Year markers
  \foreach \x/\year in {0/2003,3/2010,6/2015,9/2020,12/2025} {
    \draw (\x,0.1) -- (\x,-0.1);
    \node at (\x,-0.5) {\year};
  }

  % Events (positioned above timeline)
  \node[above,text width=3cm,align=center] at (0,0.5) {Autonomic\\Computing};
  \node[above,text width=3cm,align=center] at (3,0.5) {Proactive\\Prediction};
  \node[above,text width=3cm,align=center] at (6,0.5) {Kubernetes\\HPA};
  \node[above,text width=3cm,align=center] at (12,0.5) {\textbf{SwarmGuard}};
\end{tikzpicture}
```

================================================================================
PART 3: CHAPTER 3 FIGURES - ARCHITECTURE (Methodology - Design)
================================================================================

Chapter 3 requires the most detailed technical diagrams for system architecture,
component design, and infrastructure.

--------------------------------------------------------------------------------
FIGURE 3.1: Overall System Architecture
--------------------------------------------------------------------------------

CHAPTER SECTION: 3.2 System Architecture
PLACEMENT: First figure in methodology chapter

FIGURE TITLE:
"SwarmGuard Overall System Architecture and Component Interaction"

FIGURE CAPTION:
"High-level architecture showing four primary components: distributed monitoring
agents (one per node), centralized recovery manager (master node), external
monitoring infrastructure (InfluxDB, Grafana), and test application (web-stress).
Data flows include metrics collection (agents → InfluxDB), event-driven alerts
(agents → recovery manager), and recovery actions (recovery manager → Docker
Swarm API). Critical path (alert → decision → action) highlighted in red."

DESCRIPTION FOR LATEX (Layered Architecture Diagram):

LAYER 1 (Bottom): Infrastructure
- 5 Docker Swarm nodes (1 master + 4 workers)
- 100Mbps Ethernet network

LAYER 2: Monitoring Agents (Distributed)
- 5 monitoring-agent instances (one per node)
- Access Docker stats API
- Threshold detection logic

LAYER 3: Recovery Manager (Centralized)
- Single instance on master
- Flask HTTP server (port 5000)
- Rule engine + Docker controller

LAYER 4: Observability (External)
- InfluxDB (time-series database)
- Grafana (visualization)

DATA FLOWS:
1. Continuous: Agents → InfluxDB (batched, 10s interval) [BLUE dashed arrows]
2. Event-driven: Agents → Recovery Manager (immediate alerts) [RED solid arrows]
3. Control: Recovery Manager → Docker Swarm API [GREEN solid arrows]
4. Visualization: InfluxDB → Grafana [BLUE solid arrows]

TIKZ STRUCTURE:
```latex
\begin{tikzpicture}[
  layer/.style={rectangle,draw,thick,minimum width=14cm,minimum height=2cm,align=center},
  component/.style={rectangle,draw,thick,minimum width=2.5cm,minimum height=1cm,align=center}
]
  % Layers
  \node[layer,fill=gray!10] (infra) at (0,0) {Docker Swarm Cluster\\5 Nodes (1 Master + 4 Workers)\\100Mbps Ethernet};

  \node[layer,fill=blue!10] (agents) at (0,3) {Monitoring Agents Layer};
  \draw (agents.west) ++(1,0) node[component,fill=blue!30] {Agent-M};
  \draw (agents.west) ++(3.5,0) node[component,fill=blue!30] {Agent-W1};
  \draw (agents.west) ++(6,0) node[component,fill=blue!30] {Agent-W2};
  \draw (agents.west) ++(8.5,0) node[component,fill=blue!30] {Agent-W3};
  \draw (agents.west) ++(11,0) node[component,fill=blue!30] {Agent-W4};

  \node[layer,fill=red!10] (manager) at (0,6) {Recovery Manager\\(Master Node Only)};
  \draw (manager) node[component,fill=red!30] {Rule Engine\\Docker Controller};

  \node[layer,fill=green!10] (obs) at (0,9) {Observability Layer\\(External Raspberry Pi)};
  \draw (obs.west) ++(3,0) node[component,fill=green!30] {InfluxDB};
  \draw (obs.west) ++(8,0) node[component,fill=green!30] {Grafana};

  % Arrows (data flows)
  \draw[->,thick,blue,dashed] (agents) -- (obs) node[midway,right] {Metrics (10s)};
  \draw[->,thick,red] (agents) -- (manager) node[midway,right] {Alerts (immediate)};
  \draw[->,thick,green] (manager) -- (infra) node[midway,left] {Recovery Actions};
\end{tikzpicture}
```

LATEX PLACEMENT NOTE:
This is THE MOST IMPORTANT FIGURE in Chapter 3. Reference it multiple times
throughout methodology section. Use: "As shown in Figure 3.1, the architecture
consists of..."

--------------------------------------------------------------------------------
FIGURE 3.2: Monitoring Agent Internal Architecture
--------------------------------------------------------------------------------

CHAPTER SECTION: 3.3.1 Monitoring Agent Design
PLACEMENT: When explaining agent implementation

FIGURE TITLE:
"Monitoring Agent Internal Architecture and Data Flow"

FIGURE CAPTION:
"Internal components of a monitoring agent showing Docker stats API polling
(5-second interval), threshold evaluation logic, dual transmission paths
(InfluxDB batching and immediate alerting), and configuration from environment
variables. Async I/O prevents blocking during metric transmission."

DESCRIPTION FOR LATEX (Component Diagram):

COMPONENTS (left to right):

1. INPUT: Docker Socket (/var/run/docker.sock)
   - GET /containers/json
   - GET /containers/{id}/stats

2. COLLECTOR: Stats Processor
   - Parse CPU percentage
   - Parse memory usage
   - Calculate network percentage (RX+TX / 100Mbps)

3. EVALUATOR: Threshold Checker
   - Scenario 1: (CPU > 75 OR Mem > 80) AND Net < 35
   - Scenario 2: (CPU > 75 OR Mem > 80) AND Net > 65
   - Consecutive breach counter (2 breaches required)

4. TRANSMITTER (Dual Path):
   Path A: Alert Sender (async HTTP POST)
   - Target: recovery-manager:5000/alert
   - Payload: JSON (service, node, metrics, scenario)
   - Latency: 7-9ms

   Path B: InfluxDB Writer (batched)
   - Batch size: 20 metrics
   - Interval: 10 seconds
   - Format: InfluxDB Line Protocol

5. CONFIGURATION: Environment Variables
   - Thresholds (CPU, Memory, Network)
   - URLs (InfluxDB, Recovery Manager)
   - Poll interval

TIKZ STRUCTURE:
```latex
\begin{tikzpicture}[
  box/.style={rectangle,draw,thick,minimum width=2cm,minimum height=1.5cm,align=center},
  arrow/.style={->,>=stealth,thick}
]
  % Input
  \node[box,fill=gray!20] (docker) at (0,0) {Docker\\Socket};

  % Collector
  \node[box,fill=blue!20] (collector) at (3,0) {Stats\\Processor};

  % Evaluator
  \node[box,fill=yellow!20] (eval) at (6,0) {Threshold\\Checker};

  % Transmitter (dual path)
  \node[box,fill=red!20] (alert) at (9,1.5) {Alert\\Sender};
  \node[box,fill=green!20] (influx) at (9,-1.5) {InfluxDB\\Writer};

  % Config (top)
  \node[box,fill=purple!20] (config) at (6,3) {Environment\\Config};

  % Arrows
  \draw[arrow] (docker) -- (collector) node[midway,above] {5s poll};
  \draw[arrow] (collector) -- (eval);
  \draw[arrow] (eval) -- (alert) node[midway,above,sloped] {if violation};
  \draw[arrow] (eval) -- (influx) node[midway,below,sloped] {always};
  \draw[arrow,dashed] (config) -- (eval);
\end{tikzpicture}
```

--------------------------------------------------------------------------------
FIGURE 3.3: Recovery Manager Internal Architecture
--------------------------------------------------------------------------------

CHAPTER SECTION: 3.3.2 Recovery Manager Design
PLACEMENT: When explaining recovery manager implementation

FIGURE TITLE:
"Recovery Manager Internal Architecture and Decision Flow"

FIGURE CAPTION:
"Recovery manager components including Flask HTTP server (alert receiver),
rule engine (scenario detection), Docker controller (action executor), and
background monitoring thread (scale-down detection). Dotted line separates
foreground (event-driven) from background (polling) operations."

DESCRIPTION FOR LATEX (Component Diagram):

FOREGROUND COMPONENTS (Event-Driven):

1. HTTP Server (Flask on port 5000)
   - POST /alert endpoint
   - Request validation
   - Thread-safe queue

2. Rule Engine
   - Scenario detection (S1 vs S2)
   - Consecutive breach tracking (in-memory)
   - Cooldown enforcement (60s migration, 60s scale-up, 180s scale-down)

3. Docker Controller
   - migrate_container(): Zero-downtime migration
   - scale_up(): Incremental scaling (N → N+1)
   - Stale alert detection (verify current state)

BACKGROUND COMPONENTS (Polling):

4. Background Thread (60s interval)
   - Query service replicas
   - Calculate aggregate metrics
   - Formula: total_usage < threshold × (N - 1)
   - Sustained idle detection (180s requirement)
   - scale_down(): Conservative scaling (N → N-1)

5. Configuration Repository
   - YAML configuration (swarmguard.yaml)
   - Thresholds, cooldowns, min/max replicas
   - Loaded at startup

TIKZ STRUCTURE:
```latex
\begin{tikzpicture}[
  box/.style={rectangle,draw,thick,minimum width=2.5cm,minimum height=1.2cm,align=center},
  arrow/.style={->,>=stealth,thick}
]
  % Foreground (top half)
  \node[box,fill=blue!20] (http) at (0,4) {Flask\\Server};
  \node[box,fill=yellow!20] (rules) at (4,4) {Rule\\Engine};
  \node[box,fill=green!20] (docker) at (8,4) {Docker\\Controller};

  % Background (bottom half)
  \node[box,fill=purple!20] (thread) at (2,0) {Background\\Thread};
  \node[box,fill=orange!20] (config) at (6,0) {Config\\Repository};

  % External
  \node[box,fill=gray!20] (swarm) at (12,2) {Docker\\Swarm\\API};

  % Arrows (foreground)
  \draw[arrow] (http) -- (rules) node[midway,above] {alert};
  \draw[arrow] (rules) -- (docker) node[midway,above] {action};
  \draw[arrow] (docker) -- (swarm);

  % Arrows (background)
  \draw[arrow,dashed] (thread) -- (swarm) node[midway,above,sloped] {60s poll};
  \draw[arrow,dashed] (config) -- (rules);

  % Dividing line
  \draw[thick,dotted] (-1,2) -- (10,2);
  \node[right] at (-1,2.5) {Event-Driven};
  \node[right] at (-1,1.5) {Polling};
\end{tikzpicture}
```

--------------------------------------------------------------------------------
FIGURE 3.4: Data Flow Sequence - Normal Operation
--------------------------------------------------------------------------------

CHAPTER SECTION: 3.4 System Operation Modes
PLACEMENT: When explaining normal vs recovery operation

FIGURE TITLE:
"Sequence Diagram: Normal Operation Without Threshold Violations"

FIGURE CAPTION:
"Typical data flow during normal operation showing continuous metrics collection
(5-second interval), batched InfluxDB writes (10-second interval), and absence
of alert transmission. Recovery manager remains idle while observability stack
maintains full visibility."

DESCRIPTION FOR LATEX (UML Sequence Diagram):

ACTORS (left to right):
1. Container (web-stress replica)
2. Monitoring Agent
3. InfluxDB
4. Grafana
5. Recovery Manager

SEQUENCE:

T+0s:
Container → Agent: Docker stats API call
Agent: Parse metrics (CPU=30%, Mem=25%, Net=10%)
Agent: Threshold check (PASS, no violation)

T+5s:
Container → Agent: Docker stats API call
Agent: Parse metrics (CPU=32%, Mem=27%, Net=12%)
Agent: Threshold check (PASS, no violation)

T+10s:
Agent → InfluxDB: Batch write (20 metrics from last 10 seconds)
InfluxDB: Store in time-series database

T+15s:
Grafana → InfluxDB: Query recent metrics
InfluxDB → Grafana: Return data
Grafana: Update dashboard

Recovery Manager: (idle, no alerts received)

TIKZ STRUCTURE (Simplified Sequence):
```latex
\begin{tikzpicture}
  % Lifelines
  \draw[thick] (0,0) -- (0,-8) node[below] {Container};
  \draw[thick] (3,0) -- (3,-8) node[below] {Agent};
  \draw[thick] (6,0) -- (6,-8) node[below] {InfluxDB};
  \draw[thick] (9,0) -- (9,-8) node[below] {Manager};

  % Messages
  \draw[->,thick] (0,-1) -- (3,-1) node[midway,above] {stats};
  \draw[->,thick] (0,-3) -- (3,-3) node[midway,above] {stats};
  \draw[->,thick] (3,-5) -- (6,-5) node[midway,above] {batch write};

  % Time annotations
  \node[left] at (0,-1) {T+0s};
  \node[left] at (0,-3) {T+5s};
  \node[left] at (0,-5) {T+10s};

  % Manager idle
  \node[right,text=gray] at (9,-4) {(idle)};
\end{tikzpicture}
```

NOTE: For full UML sequence diagram, use a dedicated UML tool or PlantUML for
better formatting. TikZ structure above is simplified.

--------------------------------------------------------------------------------
FIGURE 3.5: Data Flow Sequence - Recovery Triggered
--------------------------------------------------------------------------------

CHAPTER SECTION: 3.4 System Operation Modes
PLACEMENT: Immediately after Figure 3.4

FIGURE TITLE:
"Sequence Diagram: Proactive Recovery Scenario 1 (Migration)"

FIGURE CAPTION:
"Complete sequence of events during proactive migration showing threshold
detection (10s), alert transmission (7-9ms), scenario evaluation, Docker API
interaction, and zero-downtime migration execution. Critical path from detection
to new container ready takes 6.08 seconds."

DESCRIPTION FOR LATEX (UML Sequence Diagram):

ACTORS:
1. Container (web-stress.1 on worker-3)
2. Monitoring Agent (agent-worker-3)
3. Recovery Manager
4. Docker Swarm API
5. New Container (web-stress.2 on worker-4)

SEQUENCE:

T+0s (05:54:07):
Container: CPU rises to 85.5% (threshold violation)
Container → Agent: Docker stats API
Agent: CPU=85.5%, Mem=30%, Net=8%
Agent: Evaluate scenario → Scenario 1 (high CPU, low network)
Agent: Consecutive breach count = 1

T+5s (05:54:12):
Container → Agent: Docker stats API (still high)
Agent: CPU=85.2%, still above threshold
Agent: Consecutive breach count = 2 (TRIGGER)
Agent → Recovery Manager: HTTP POST /alert (JSON payload)
Latency: 7ms

T+5.01s:
Recovery Manager: Receive alert
Recovery Manager: Cooldown check (PASS)
Recovery Manager: Scenario 1 confirmed → migrate_container()
Recovery Manager: Verify current node (stale alert check)
Recovery Manager → Docker API: service.update() with START-FIRST order

T+6s (05:54:13):
Docker API: Create new task on worker-4
Docker API: Pull image (if needed)
New Container: Container starting

T+11s (05:54:18):
New Container: Health check PASS
Docker API: New task → "Running" state
Docker API: Send SIGTERM to old container
Container: Graceful shutdown (5s grace period)

T+11.08s (05:54:18.08):
Container: Stopped
Migration complete
MTTR: 6.08 seconds
Downtime: 0 seconds (overlap from T+6 to T+11)

TIKZ STRUCTURE (Simplified):
```latex
\begin{tikzpicture}
  % Lifelines
  \draw[thick] (0,0) -- (0,-10);
  \draw[thick] (3,0) -- (3,-10);
  \draw[thick] (6,0) -- (6,-10);
  \draw[thick] (9,0) -- (9,-10);
  \draw[thick] (12,0) -- (12,-10);

  % Labels
  \node[above] at (0,0) {Container};
  \node[above] at (3,0) {Agent};
  \node[above] at (6,0) {Manager};
  \node[above] at (9,0) {Docker API};
  \node[above] at (12,0) {New Container};

  % Key events
  \draw[->,thick,red] (0,-1) -- (3,-1) node[midway,above] {85\% CPU};
  \draw[->,thick,red] (3,-3) -- (6,-3) node[midway,above] {alert (7ms)};
  \draw[->,thick,red] (6,-4) -- (9,-4) node[midway,above] {migrate};
  \draw[->,thick,green] (9,-5) -- (12,-5) node[midway,above] {create task};
  \draw[->,thick,green] (12,-7) -- (9,-7) node[midway,above] {health OK};
  \draw[->,thick,blue] (9,-8) -- (0,-8) node[midway,above] {SIGTERM};

  % Time annotations
  \node[left] at (-0.5,-1) {T+0s};
  \node[left] at (-0.5,-3) {T+5s};
  \node[left] at (-0.5,-8) {T+11s};
\end{tikzpicture}
```

ACADEMIC WRITING TIP:
Reference this figure when explaining the end-to-end recovery workflow:
"Figure 3.5 illustrates the complete sequence from threshold detection to
migration completion, demonstrating the 6.08-second MTTR achievement."

--------------------------------------------------------------------------------
FIGURE 3.6: Zero-Downtime Migration Algorithm (Flowchart)
--------------------------------------------------------------------------------

CHAPTER SECTION: 3.5.1 Migration Algorithm
PLACEMENT: When describing migration implementation

FIGURE TITLE:
"Zero-Downtime Migration Algorithm Flowchart"

FIGURE CAPTION:
"Step-by-step algorithm for proactive container migration ensuring zero downtime
through START-FIRST rolling update ordering. Critical steps include stale alert
detection (Step 1), placement constraint configuration (Step 2), rolling update
with overlap (Steps 3-4), health check validation (Step 5), and constraint
cleanup (Step 6)."

DESCRIPTION FOR LATEX (TikZ Flowchart):

FLOWCHART STEPS:

START
  ↓
[1] INPUT: Alert(service_name, current_node, metrics)
  ↓
[2] DECISION: Is container still on reported node?
  NO → Log "Stale alert" → RETURN (exit)
  YES ↓
[3] Configure placement constraint
    new_constraints = base + ["node.hostname!={current_node}"]
  ↓
[4] Configure rolling update strategy
    update_config = {
      'Parallelism': 1,
      'Delay': 0,
      'Order': 'start-first',  ← KEY STEP
      'FailureAction': 'pause'
    }
  ↓
[5] Trigger Docker Swarm update
    api.update_service(service_id, ...)
    Increment ForceUpdate counter
  ↓
[6] WAIT: New container created and starting
    (Docker handles automatically)
  ↓
[7] WAIT: Health checks pass
    (Docker waits before stopping old container)
  ↓
[8] Docker automatically stops old container
    (SIGTERM with 5s grace period)
  ↓
[9] Remove migration constraints
    Restore original constraints (all nodes available)
  ↓
[10] Log migration success
  ↓
END

PARALLELISM NOTE (visualize in diagram):
Timeline showing OLD and NEW containers:
T+0: OLD running, NEW starting
T+6: OLD running, NEW running ← BOTH RUNNING (zero downtime)
T+11: OLD stopped, NEW running

TIKZ STRUCTURE:
```latex
\begin{tikzpicture}[
  process/.style={rectangle,draw,thick,minimum width=3cm,minimum height=1cm,align=center},
  decision/.style={diamond,draw,thick,minimum width=2.5cm,minimum height=1.5cm,align=center,aspect=2},
  arrow/.style={->,>=stealth,thick}
]
  % Start
  \node[draw,circle] (start) at (0,0) {START};

  % Step 1
  \node[process] (input) at (0,-1.5) {Receive Alert};

  % Step 2 (decision)
  \node[decision] (stale) at (0,-3.5) {Container\\on node?};
  \node[process] (log) at (4,-3.5) {Log stale};

  % Step 3
  \node[process] (constraint) at (0,-6) {Configure\\Constraints};

  % Step 4 (highlighted)
  \node[process,fill=yellow!30] (startfirst) at (0,-8) {Set\\START-FIRST\\Order};

  % Step 5
  \node[process] (api) at (0,-10) {Docker\\API Call};

  % Step 6-7
  \node[process] (wait) at (0,-12) {Wait for\\Health Checks};

  % Step 8
  \node[process] (cleanup) at (0,-14) {Remove\\Constraints};

  % End
  \node[draw,circle] (end) at (0,-16) {END};

  % Arrows
  \draw[arrow] (start) -- (input);
  \draw[arrow] (input) -- (stale);
  \draw[arrow] (stale) -- (log) node[midway,above] {NO};
  \draw[arrow] (stale) -- (constraint) node[midway,right] {YES};
  \draw[arrow] (constraint) -- (startfirst);
  \draw[arrow] (startfirst) -- (api);
  \draw[arrow] (api) -- (wait);
  \draw[arrow] (wait) -- (cleanup);
  \draw[arrow] (cleanup) -- (end);
  \draw[arrow] (log) -- (end);

  % Annotation for START-FIRST
  \node[right,text width=4cm] at (4,-8) {\textbf{KEY:} Starts new\\before stopping old\\→ Zero downtime};
\end{tikzpicture}
```

CRITICAL ACADEMIC NOTE:
This flowchart demonstrates your PRIMARY TECHNICAL CONTRIBUTION. The START-FIRST
ordering (Step 4) is the key innovation enabling zero-downtime migration.
Reference this figure extensively in methodology and discussion chapters.

Use in text: "As illustrated in Figure 3.6, the migration algorithm's critical
step is configuring the START-FIRST rolling update order (Step 4), which ensures
the new container is fully operational before the old container is terminated."

================================================================================
END OF PART 1 (Chapters 1-2 and Start of Chapter 3 Architecture)
================================================================================

This file continues in FYP_FIGURE_PLAN_PART2_RESULTS.txt with:
- Remaining Chapter 3 figures (Algorithms, Infrastructure, Testing)
- All Chapter 4 figures (Results, Performance, Evaluation)
- LaTeX best practices and templates
